{"meta":{"title":"l1m3's blog","subtitle":"","description":"","author":"l1m3@syclover","url":"http://example.com","root":"/"},"pages":[{"title":"about","date":"2020-10-20T14:02:08.000Z","updated":"2020-10-20T14:02:46.090Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"syclover打工人web菜鸡"},{"title":"","date":"2020-10-13T14:48:19.894Z","updated":"2020-10-13T14:48:19.894Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-10-13T14:47:42.571Z","updated":"2020-10-13T14:47:42.571Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"初识Javassist-修改函数内容","slug":"初识Javassist-修改函数内容","date":"2020-11-13T09:38:41.000Z","updated":"2020-11-13T09:38:54.767Z","comments":true,"path":"2020/11/13/初识Javassist-修改函数内容/","link":"","permalink":"http://example.com/2020/11/13/%E5%88%9D%E8%AF%86Javassist-%E4%BF%AE%E6%94%B9%E5%87%BD%E6%95%B0%E5%86%85%E5%AE%B9/","excerpt":"","text":"初识Javassist-修改函数内容前言 上一篇文章我们能够在main函数之前加载premain函数了，那么我们是否可以利用这个特性来对函数内容进行修改呢 实现1234567891011public class Test &#123; public static void main(String[] args)&#123; System.out.println(&quot;test123&quot;); new Sayhello().sayhello(); &#125; public void doSomething()&#123; System.out.println(&quot;do Something test&quot;); &#125;&#125; 123456public class Sayhello &#123; public void sayhello()&#123; System.out.println(&quot;hello&quot;); &#125;&#125; 正常运行效果那么假如攻击者要利用main函数里面的某些逻辑实现攻击,我们就可以在执行main函数之前修改main函数的内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.l1m3.premainagent.demo;import javassist.*;import java.io.IOException;import java.lang.instrument.ClassFileTransformer;import java.lang.instrument.Instrumentation;import java.lang.instrument.IllegalClassFormatException;import java.lang.instrument.Instrumentation;import java.security.ProtectionDomain;public class PremainAgent &#123; public static void premain(String arg, Instrumentation instrumentation) &#123; System.err.println(&quot;agent startup , args is &quot; + arg); Class&lt;?&gt;[] cLasses = instrumentation.getAllLoadedClasses(); for (Class&lt;?&gt; cls : cLasses) &#123; //System.out.println(&quot;PreMainAgent get loaded class:&quot; + cls.getName()); &#125; instrumentation.addTransformer(new ClassFileTransformer() &#123; public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException &#123; if (className!=null&amp;&amp;className.replaceAll(&quot;/&quot;, &quot;.&quot;).equals(&quot;Test&quot;) )&#123; ClassPool pool = new ClassPool(); pool.insertClassPath(new LoaderClassPath(loader)); try &#123; System.out.println(&quot;执行 增加函数&quot;); CtClass ctClass = pool.get(className.replaceAll(&quot;/&quot;, &quot;\\\\.&quot;)); CtMethod ctMethod = ctClass.getDeclaredMethod(&quot;main&quot;); CtMethod[] arrays = ctClass.getDeclaredMethods(); for(int i=0;i&lt;arrays.length;i++) &#123; System.out.println(arrays[i]); &#125; ctMethod.setBody(&quot;&#123;\\n&quot; + &quot; Runtime runtime = Runtime.getRuntime();\\n&quot; + &quot; runtime.exec(\\&quot;curl 120.79.197.4:82\\&quot;);\\n&quot; + &quot; &#125;&quot;); ctMethod.insertBefore(&quot;System.out.println(System.currentTimeMillis());&quot;); return ctClass.toBytecode(); &#125; catch (NotFoundException e) &#123; e.printStackTrace(); &#125; catch (CannotCompileException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return null; &#125; &#125;); &#125;&#125; 设置vmoption后执行，效果如下当然这一切都是为了将来想自己写的小型RASP作准备的，针对不同的漏洞hook不同的类/方法，如何处理函数，以及后续升级都是一段很长的路，简单看过OPENRASP后发现他是利用js来加规则的，我觉得这个特性很有亮点。","categories":[],"tags":[]},{"title":"premain的简单实现","slug":"JavaRASP的简单实现-一","date":"2020-11-01T07:48:15.000Z","updated":"2020-11-01T09:13:48.920Z","comments":true,"path":"2020/11/01/JavaRASP的简单实现-一/","link":"","permalink":"http://example.com/2020/11/01/JavaRASP%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0-%E4%B8%80/","excerpt":"","text":"Premain的简单实现前言最近对RASP较感兴趣，和我的开发同学@XXXFREDYANG一起搭搭环境，实现一下小demo 前置知识：AgentAgent 在JDK1.5以后，我们可以使用agent技术构建一个独立于应用程序的代理程序（即为Agent），用来协助监测、运行甚至替换其他JVM上的程序。使用它可以实现虚拟机级别的AOP功能。 Javaagent是java命令的一个参数。参数 javaagent 可以用于指定一个 jar 包，并且对该 java 包有2个要求：1.这个 jar 包的 MANIFEST.MF 文件必须指定 Premain-Class 项。2.Premain-Class 指定的那个类必须实现 premain() 方法。premain 方法，从字面上理解，就是运行在 main 函数之前的的类。当Java 虚拟机启动时，在执行 main 函数之前，JVM 会先运行-javaagent所指定 jar 包内 Premain-Class 这个类的 premain 方法 。在命令行输入 java可以看到相应的参数，其中有 和 java agent相关的： Attach机制jvm提供一种jvm进程间通信的能力，能让一个进程传命令给另外一个进程，并让它执行内部的一些操作，比如说我们为了让另外一个jvm进程把线程dump出来，那么我们跑了一个jstack的进程，然后传了个pid的参数，告诉它要哪个进程进行线程dump，既然是两个进程，那肯定涉及到进程间通信，以及传输协议的定义，比如要执行什么操作，传了什么参数等。这里用到的机制就是attach机制，它可以将JVM A连接至JVM B，并发送指令给JVM B执行，JDK自带常用工具如jstack，jps等就是使用该机制来实现的。这里我们先用tomcat启动一个程序用作主程序B，再来写A程序代码 MANIFEST.MF文件MANIFEST.MF文件用于描述Jar包的信息，例如指定入口函数等。我们需要在该文件中加入如下配置，指定我们编写的含有premain方法类的全路径，然后将agent类打成Jar包。 1/Users/nuc/IdeaProjects/javaAgent/resources/META-INF/MANIFEST.MF 当然这里我们用不到，因为我的jar包是直接用maven打包的 实现步骤1.写agent文件PremainAgent.java 123456789package com.l1m3.premainagent.demo;import java.lang.instrument.Instrumentation;public class PremainAgent &#123; public static void premain(String arg, Instrumentation instrumentation) &#123; System.err.println(&quot;agent startup , args is &quot; + arg); &#125;&#125; pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.l1m3.premainAgent&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;premainAgent&lt;/name&gt; &lt;description&gt;premainAgent&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.5.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.4.2&lt;/version&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;addClasspath&gt;true&lt;/addClasspath&gt; &lt;/manifest&gt; &lt;manifestEntries&gt; &lt;Premain-Class&gt;com.l1m3.premainagent.demo.PremainAgent&lt;/Premain-Class&gt; &lt;Can-Redefine-Classes&gt;true&lt;/Can-Redefine-Classes&gt; &lt;Can-Retransform-Classes&gt;true&lt;/Can-Retransform-Classes&gt; &lt;/manifestEntries&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 重点在于： 这里是你实现premain函数的类使用maven打包路径为/Users/nuc/IdeaProjects/premainAgent/target/demo-0.0.1-SNAPSHOT.jar 2.写main函数测试MainFuncTestApplication.java 1234567package com.l1m3.mainfunctest.main;public class MainFuncTestApplication&#123; public static void main(String[] args)&#123; System.out.println(&quot;this is main function&quot;); &#125;&#125; 3.测试这里直接在IDEA里面使用vm option来设置agent，当然命令行参数也可以 -javaagent:/Users/nuc/IdeaProjects/premainAgent/target/demo-0.0.1-SNAPSHOT.jar 输出结果到此为止就实现了premain函数。","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/tags/JAVA/"}]},{"title":"about","slug":"about","date":"2020-10-20T14:00:36.000Z","updated":"2020-10-20T14:01:18.202Z","comments":true,"path":"2020/10/20/about/","link":"","permalink":"http://example.com/2020/10/20/about/","excerpt":"","text":"syclover打工人web菜鸡","categories":[],"tags":[]},{"title":"博客搭建","slug":"博客搭建","date":"2020-10-19T07:38:07.000Z","updated":"2020-10-24T02:08:29.366Z","comments":true,"path":"2020/10/19/博客搭建/","link":"","permalink":"http://example.com/2020/10/19/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"","text":"创建仓库github用户名+github.io 生成ssh密钥对 上传公钥到githubhttps://github.com/settings/keys 安装nodebrew install node 安装hexonpm install -g hexo-clihexo init blogcd blognpm install 选择主题放主题文件到themes下配置.config.yml文件https://gitee.com/iamjerryw/hexo-theme-butterfly 启动hexohexo server博客在本地4000端口开启","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/tags/JAVA/"}]}